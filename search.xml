<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何利用 Git 充分管理?</title>
      <link href="/ru-he-li-yong-git-chong-fen-guan-li.html"/>
      <url>/ru-he-li-yong-git-chong-fen-guan-li.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-操作详解"><a href="#Git-操作详解" class="headerlink" title="Git 操作详解"></a>Git 操作详解</h1><hr><p>使用 Git 的时候零星地记得一些语句，不够熟练且易忘，因此做个常用总结。</p><h2 id="Git-主要操作"><a href="#Git-主要操作" class="headerlink" title="Git 主要操作"></a>Git 主要操作</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="1-提交-commit"><a href="#1-提交-commit" class="headerlink" title="1.提交(commit)"></a>1.提交(commit)</h4><blockquote><p>创建一个新的提交记录</p></blockquote><pre><code>git commit</code></pre><blockquote><p>创建一个新的提交记录,并且附加说明</p></blockquote><pre><code>git commit -m &quot;提交说明&quot;//说明建议英文</code></pre><h4 id="2-分支-branch"><a href="#2-分支-branch" class="headerlink" title="2.分支(branch)"></a>2.分支(branch)</h4><blockquote><p>创建一个新的分支</p></blockquote><pre><code>git branch &lt;branch-name&gt;</code></pre><blockquote><p>切换到某一分支</p></blockquote><pre><code>git checkout &lt;branch-name&gt;</code></pre><blockquote><p>创建一个新并切换到这一分支</p></blockquote><pre><code>git checkout -b &lt;branch-name&gt;</code></pre><h4 id="3-合并-merge"><a href="#3-合并-merge" class="headerlink" title="3.合并(merge)"></a>3.合并(merge)</h4><blockquote><p>合并分支，要注意当前分支!!!<br>与 rebase 不同，将 A 合并到 B 要先切换到 B 分支，再 merge A</p></blockquote><pre><code>git merge &lt;branch-name&gt;</code></pre><blockquote><p>将 A 分支上的 X 文件 合并到 B 上 (类似复制粘贴)</p></blockquote><pre><code>git checkout Bgit checkout A X</code></pre><h4 id="4-合并-rebase"><a href="#4-合并-rebase" class="headerlink" title="4.合并(rebase)"></a>4.合并(rebase)</h4><blockquote><p>合并分支,能够线性得展示 git记录, 但原分支将会继续存在，要注意当前分支!!!<br>与 merge 不同，将 A 合并到 B 要先切换到 A 分支，再 rebase B</p></blockquote><pre><code>git rebase &lt;branch-name&gt;</code></pre><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><h4 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h4><blockquote><p>HEAD是一个指针，通常情况下它可以将它与当前分支等同（其实它是指向当前分支）。<br>.git 目录中有一个为 HEAD 的文件，它记录着 HEAD 的内容，查询代码如下：</p></blockquote><pre><code>cat .git/HEAD//ref: refs/heads/master</code></pre><blockquote><p>查看HEAD对应的指针位置</p></blockquote><pre><code>cat .git/refs/heads/backup//一段长度为40的sha-1字符串值</code></pre><h4 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用(^)"></a>相对引用(^)</h4><blockquote><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便，所以有了相对引用</p></blockquote><pre><code>git checkout master^    //向上移动 1 个提交记录git checkout HEAD^      //将 HEAD 指针向上移动 1 个提交记录</code></pre><h4 id="相对引用-1"><a href="#相对引用-1" class="headerlink" title="相对引用(~)"></a>相对引用(~)</h4><blockquote><p>如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的</p></blockquote><pre><code>git checkout master~          //一次向上移动 1 个提交记录git checkout master~3         //一次向上移动 3 个提交记录git branch -f master HEAD~3   //-f 容许我们将 master 分支强制移动到那个位置</code></pre><h4 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h4><blockquote><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成<br>git reset 通过把分支记录回退几个提交记录来实现撤销改动，原来指向的提交记录就跟从来没有提交过一样</p></blockquote><pre><code>git reset HEAD~1  //回退一次</code></pre><blockquote><p>为了撤销更改并分享给别人<br>git revert 将会创建新提交，新提交的状态和内容与之前的某一版本一致，便于分享</p></blockquote><pre><code>git revert HEAD</code></pre><h3 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h3><h4 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h4><blockquote><p>如果你想将一些提交复制到当前所在的位置 HEAD 下面的话， Cherry-pick 是最直接的方式了。</p></blockquote><pre><code>git cherry-pick &lt;提交名称1&gt; &lt;提交名称2&gt;...</code></pre><h4 id="交互式-rebase"><a href="#交互式-rebase" class="headerlink" title="交互式 rebase"></a>交互式 rebase</h4><blockquote><p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i<br>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，<br>它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p></blockquote><pre><code>git rebase -i HEAD~3//从当前分支算起，向前 3 次，共可对 3 个提交进行排序，也可忽略其中某些提交</code></pre><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="只取一个提交记录"><a href="#只取一个提交记录" class="headerlink" title="只取一个提交记录"></a>只取一个提交记录</h4><blockquote><p>可以选择通过 fast-forward 快速合并,但会包含不必要的信息<br>通常可以直接 cherry-pick 复制那一个记录</p></blockquote><h4 id="提交的技巧-一"><a href="#提交的技巧-一" class="headerlink" title="提交的技巧(一)"></a>提交的技巧(一)</h4><blockquote><p>先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前<br>然后用 commit –amend 来进行一些小修改<br>接着再用 git rebase -i 来将他们调回原来的顺序<br>最后我们把 master 移到修改的最前端，就大功告成啦！</p></blockquote><pre><code>git rebase -igit commit --amendgit rebase -igit rebase &lt;branch-name&gt;</code></pre><h4 id="提交的技巧-二"><a href="#提交的技巧-二" class="headerlink" title="提交的技巧(二)"></a>提交的技巧(二)</h4><blockquote><p>我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 –amend 修改它，然后把它们重新排成我们想要的顺序<br>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突</p></blockquote><pre><code>git cherry-pick &lt;branch-name&gt;git rebase -i HEAD  //回退到你需要的提交历史git cherry-pick &lt;branch-name&gt;</code></pre><h4 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h4><blockquote><p>它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了<br>它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置</p></blockquote><pre><code>git tag &lt;tag-name&gt; &lt;branch-name&gt;</code></pre><h4 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h4><blockquote><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是有些遗忘了， 可能会用到这个命令。</p></blockquote><pre><code>git describe &lt;ref&gt;&lt;ref&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）输出的结果为:&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位当 ref 提交记录上有某个标签时，则只输出标签名称 </code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h4><blockquote><p>可以选择多次 git rebase -i 拉取到一条提交线上，最后合并 master ,但是过于繁琐<br>建议直接 git cherry-pick </p></blockquote><h4 id="选择父提交记录"><a href="#选择父提交记录" class="headerlink" title="选择父提交记录"></a>选择父提交记录</h4><blockquote><p>操作符 ^ 后面也可以跟一个数字。<br>但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。<br>Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。</p></blockquote><pre><code>git checkout HEAD^ 等价于 git checkout HEAD~git checkout HEAD^2</code></pre><blockquote><p>支持链式操作</p><pre><code>git checkout HEAD~^2~2</code></pre></blockquote><h2 id="Git-远程操作"><a href="#Git-远程操作" class="headerlink" title="Git 远程操作"></a>Git 远程操作</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="Git-Clone"><a href="#Git-Clone" class="headerlink" title="Git Clone"></a>Git Clone</h4><pre><code>git clone &lt;http-name&gt;</code></pre><h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><blockquote><p>远程分支反映了远程仓库(在你上次和它通信时)的状态<br>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态</p></blockquote><h4 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h4><blockquote><p>从远程仓库下载本地仓库中缺失的提交记录<br>更新远程分支指针<br>理解为单纯的下载操作，不会改变本地仓库的状态</p></blockquote><pre><code>git fetch</code></pre><h4 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h4><blockquote><p>抓取更新再合并到本地分支<br>等价于 git fetch 和 git merge 的结合</p></blockquote><pre><code>git pull</code></pre><h4 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h4><blockquote><p>将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录</p></blockquote><pre><code>git push</code></pre><h4 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h4><blockquote><p>当远程仓库与本地仓库的提交历史不一致，git push 不允许有变更<br>可以先 git fetch 然后 git rebase/git merge 合并，再 git push</p></blockquote><pre><code>git pull --rebasegit push</code></pre><h3 id="远程仓库进阶"><a href="#远程仓库进阶" class="headerlink" title="远程仓库进阶"></a>远程仓库进阶</h3><h4 id="利用-rebase-推送主分支"><a href="#利用-rebase-推送主分支" class="headerlink" title="利用 rebase 推送主分支"></a>利用 rebase 推送主分支</h4><blockquote><ul><li>将特性分支集成到 master 上</li><li>推送并更新远程分支</li></ul></blockquote><pre><code>git pull --rebasegit rebase...     //在 master 分支下合并git push</code></pre><h4 id="利用-merge-推送主分支"><a href="#利用-merge-推送主分支" class="headerlink" title="利用 merge 推送主分支"></a>利用 merge 推送主分支</h4><blockquote><p>效果与 rebase 相同<br>但可保留提交历史</p></blockquote><pre><code>git pull --rebasegit merge ...     //在 master 分支下合并git push</code></pre><h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h4><blockquote><ul><li>pull 操作时, 提交记录会被先下载到 o/master 上，之后再合并到本地的 master 分支。隐含的合并目标由这个关联确定的。</li><li>push 操作时, 我们把工作从 master 推到远程仓库中的 master 分支(同时会更新远程分支 o/master) 。这个推送的目的地也是由这种关联确定的！<br>因为在 clone 时，Git 会自动创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 master<br>所有我们通常能看到这个语句:<br><code>local branch &quot;master&quot; set to track remote branch &quot;o/master&quot;</code><br>也可自定义该属性</li></ul></blockquote><p>1.<code>`</code><br>git checkout -b <newbrach> &lt;o/master&gt;<br>创建一个名为 <newbrach> 的分支，它跟踪远程分支 o/master</newbrach></newbrach></p><pre><code>2.</code></pre><p>git branch -u o/master <newbrach></newbrach></p><pre><code>#### Git Push 的参数Ⅰ&gt;切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去</code></pre><p>git push <origin> <master></master></origin></p><pre><code>#### Git Push 的参数Ⅱ&gt;同时为源和目的地指定 &lt;place&gt; 的话，只需要用冒号 : 将二者连起来就&gt;同时在本地创建 source 分支，连接到远程 destination 分支，如果不存在，自动创建</code></pre><p>git push origin <source>:<destination><br>git push origin <source>~2:<destination></destination></destination></p><pre><code>#### Git Fetch 的参数&gt;由于变成了从远程下载内容到本地，所以与git push 的参数意义相反&gt;destination 代表远程分支&gt;source 代表本地分支，如果不存在，自动创建</code></pre><p>git fetch origin <destination>:<source></destination></p><pre><code>#### &lt;source&gt; 留空&gt;Git 有两种关于 &lt;source&gt; 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 source，方法就是仅保留冒号和 destination 部分，source 部分留空</code></pre><p>git push origin :<destination><br>如果 push 空 <source> 到远程仓库，会删除远程仓库中的分支！<br>git fetch origin :<destination><br>如果 fetch 空 <source> 到本地，会在本地创建一个新分支！</destination></destination></p><pre><code>#### Git Pull 参数&gt;参数类似于 git push 的参数</code></pre><p>git pull origin <destination>:<source><br><code>`</code></destination></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何管理你的NPM?</title>
      <link href="/ru-he-guan-li-ni-de-npm.html"/>
      <url>/ru-he-guan-li-ni-de-npm.html</url>
      
        <content type="html"><![CDATA[<h2 id="利用-nrm-一键管理-NPM"><a href="#利用-nrm-一键管理-NPM" class="headerlink" title="利用 nrm 一键管理 NPM"></a>利用 nrm 一键管理 NPM</h2><hr><p>当使用官方npm源安装各种包比较慢的时候，建议修改npm源地址</p><h3 id="查看-npm-源地址"><a href="#查看-npm-源地址" class="headerlink" title="查看 npm 源地址"></a>查看 npm 源地址</h3><p>在终端输入以下命令</p><pre><code>npm config list//metrics-registry = &quot;https://registry.npmjs.org/&quot;</code></pre><h3 id="切换-npm-地址"><a href="#切换-npm-地址" class="headerlink" title="切换 npm 地址"></a>切换 npm 地址</h3><p>国内常用的镜像地址如淘宝:</p><pre><code>npm set registry https://registry.npm.taobao.org/</code></pre><blockquote><p>但是因为发现一直切换来删除去特别麻烦<br>因此就出现了 nrm : NPM registry manager<br>顾名思义: nrm是专门用来管理和快速切换私人配置的 registry 这么一项工具</p></blockquote><h3 id="全局安装-nrm"><a href="#全局安装-nrm" class="headerlink" title="全局安装 nrm"></a>全局安装 nrm</h3><pre><code>npm install nrm -g --save</code></pre><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><pre><code>nrm ls</code></pre><p><img src="https://github.com/amazingzcj/amazingzcj.github.io/blob/master/medias/contentimages/nrm/nrm.png" alt="nrm" title="nrm ls"></p><h3 id="查看当前使用的-npm-源"><a href="#查看当前使用的-npm-源" class="headerlink" title="查看当前使用的 npm 源"></a>查看当前使用的 npm 源</h3><pre><code>nrm current</code></pre><h3 id="切换-npm-源"><a href="#切换-npm-源" class="headerlink" title="切换 npm 源"></a>切换 npm 源</h3><pre><code>nrm use taobao</code></pre><h3 id="测试速度"><a href="#测试速度" class="headerlink" title="测试速度"></a>测试速度</h3><pre><code>nrm test taobao// taobao - 165ms</code></pre><h3 id="添加私有-npm-源"><a href="#添加私有-npm-源" class="headerlink" title="添加私有 npm 源"></a>添加私有 npm 源</h3><pre><code>nrm add amazingzcj http://amazing.npm// amazingzcj -- http://amazing.npm</code></pre><h3 id="删除已配置-npm"><a href="#删除已配置-npm" class="headerlink" title="删除已配置 npm"></a>删除已配置 npm</h3><pre><code>nrm del amazingzcj</code></pre>]]></content>
      
      
      <categories>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
            <tag> nrm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
